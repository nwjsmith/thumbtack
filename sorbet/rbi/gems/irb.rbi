# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/irb/all/irb.rbi
#
# irb-1.3.4

module IRB
  def self.CurrentContext; end
  def self.Inspector(inspect, init = nil); end
  def self.conf; end
  def self.default_src_encoding; end
  def self.delete_caller; end
  def self.easter_egg(type = nil); end
  def self.init_config(ap_path); end
  def self.init_error; end
  def self.irb_abort(irb, exception = nil); end
  def self.irb_at_exit; end
  def self.irb_exit(irb, ret); end
  def self.load_modules; end
  def self.parse_opts(argv: nil); end
  def self.rc_file(ext = nil); end
  def self.rc_file_generators; end
  def self.run_config; end
  def self.set_encoding(extern, intern = nil, override: nil); end
  def self.set_measure_callback(type = nil, arg = nil, &block); end
  def self.setup(ap_path, argv: nil); end
  def self.start(ap_path = nil); end
  def self.unset_measure_callback(type = nil); end
  def self.version; end
end
class IRB::DefaultEncodings < Struct
  def external; end
  def external=(_); end
  def internal; end
  def internal=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class IRB::WorkSpace
  def binding; end
  def code_around_binding; end
  def evaluate(context, statements, file = nil, line = nil); end
  def filter_backtrace(bt); end
  def initialize(*main); end
  def local_variable_get(name); end
  def local_variable_set(name, value); end
  def main; end
end
class IRB::Inspector
  def init; end
  def initialize(inspect_proc, init_proc = nil); end
  def inspect_value(v); end
  def self.def_inspector(key, arg = nil, &block); end
  def self.keys_with_inspector(inspector); end
end
module IRB::InputCompletor
  def self.ignored_modules; end
  def self.retrieve_completion_data(input, bind: nil, doc_namespace: nil); end
  def self.select_message(receiver, message, candidates, sep = nil); end
end
class IRB::InputMethod
  def file_name; end
  def gets; end
  def initialize(file = nil); end
  def inspect; end
  def prompt; end
  def prompt=(arg0); end
  def readable_after_eof?; end
  def winsize; end
end
class IRB::StdioInputMethod < IRB::InputMethod
  def encoding; end
  def eof?; end
  def gets; end
  def initialize; end
  def inspect; end
  def line(line_no); end
  def readable_after_eof?; end
end
class IRB::FileInputMethod < IRB::InputMethod
  def close; end
  def encoding; end
  def eof?; end
  def file_name; end
  def gets; end
  def initialize(file); end
  def inspect; end
  def self.open(file, &block); end
end
class IRB::ReadlineInputMethod < IRB::InputMethod
  def encoding; end
  def eof?; end
  def gets; end
  def initialize; end
  def inspect; end
  def line(line_no); end
  def readable_after_eof?; end
  def self.initialize_readline; end
end
class IRB::ReidlineInputMethod < IRB::InputMethod
  def auto_indent(&block); end
  def check_termination(&block); end
  def dynamic_prompt(&block); end
  def encoding; end
  def eof?; end
  def gets; end
  def initialize; end
  def inspect; end
  def line(line_no); end
  def readable_after_eof?; end
  include Reline
end
class IRB::OutputMethod
  def parse_printf_format(format, opts); end
  def pp(*objs); end
  def ppx(prefix, *objs); end
  def print(*opts); end
  def printf(format, *opts); end
  def printn(*opts); end
  def puts(*objs); end
end
class IRB::OutputMethod::NotImplementedError < StandardError
  def initialize(val); end
end
class IRB::StdioOutputMethod < IRB::OutputMethod
  def print(*opts); end
end
class IRB::Context
  def __exit__(*arg0); end
  def __inspect__; end
  def __to_s__; end
  def ap_name; end
  def ap_name=(arg0); end
  def auto_indent_mode; end
  def auto_indent_mode=(arg0); end
  def back_trace_limit; end
  def back_trace_limit=(arg0); end
  def echo; end
  def echo=(arg0); end
  def echo?; end
  def echo_on_assignment; end
  def echo_on_assignment=(arg0); end
  def echo_on_assignment?; end
  def eval_history=(*opts, &b); end
  def evaluate(line, line_no, exception: nil); end
  def exit(ret = nil); end
  def file_input?; end
  def ignore_eof; end
  def ignore_eof=(arg0); end
  def ignore_eof?; end
  def ignore_sigint; end
  def ignore_sigint=(arg0); end
  def ignore_sigint?; end
  def initialize(irb, workspace = nil, input_method = nil); end
  def inspect; end
  def inspect?; end
  def inspect_last_value; end
  def inspect_mode; end
  def inspect_mode=(opt); end
  def io; end
  def io=(arg0); end
  def irb; end
  def irb=(arg0); end
  def irb_name; end
  def irb_name=(arg0); end
  def irb_path; end
  def irb_path=(arg0); end
  def last_value; end
  def load_modules; end
  def load_modules=(arg0); end
  def main; end
  def newline_before_multiline_output; end
  def newline_before_multiline_output=(arg0); end
  def newline_before_multiline_output?; end
  def prompt_c; end
  def prompt_c=(arg0); end
  def prompt_i; end
  def prompt_i=(arg0); end
  def prompt_mode; end
  def prompt_mode=(mode); end
  def prompt_n; end
  def prompt_n=(arg0); end
  def prompt_s; end
  def prompt_s=(arg0); end
  def prompting?; end
  def rc; end
  def rc=(arg0); end
  def rc?; end
  def return_format; end
  def return_format=(arg0); end
  def save_history=(*opts, &b); end
  def set_last_value(value); end
  def thread; end
  def to_s; end
  def use_colorize; end
  def use_colorize?; end
  def use_loader=(*opts, &b); end
  def use_multiline; end
  def use_multiline?; end
  def use_readline; end
  def use_readline?; end
  def use_reidline; end
  def use_reidline?; end
  def use_singleline; end
  def use_singleline?; end
  def use_tracer=(*opts, &b); end
  def verbose; end
  def verbose=(arg0); end
  def verbose?; end
  def workspace; end
  def workspace=(arg0); end
  def workspace_home; end
end
module IRB::ExtendCommandBundle
  def install_alias_method(to, from, override = nil); end
  def irb(*opts, &b); end
  def irb_change_workspace(*opts, &b); end
  def irb_context; end
  def irb_current_working_workspace(*opts, &b); end
  def irb_exit(ret = nil); end
  def irb_fg(*opts, &b); end
  def irb_help(*opts, &b); end
  def irb_info(*opts, &b); end
  def irb_jobs(*opts, &b); end
  def irb_kill(*opts, &b); end
  def irb_load(*opts, &b); end
  def irb_pop_workspace(*opts, &b); end
  def irb_push_workspace(*opts, &b); end
  def irb_require(*opts, &b); end
  def irb_source(*opts, &b); end
  def irb_workspaces(*opts, &b); end
  def measure(*opts, &b); end
  def self.def_extend_command(cmd_name, cmd_class, load_file = nil, *aliases); end
  def self.extend_object(obj); end
  def self.install_extend_commands; end
  def self.irb_original_method_name(method_name); end
end
module IRB::ContextExtender
  def self.def_extend_command(cmd_name, load_file, *aliases); end
  def self.install_extend_commands; end
end
module IRB::MethodExtender
  def def_post_proc(base_method, extend_method); end
  def def_pre_proc(base_method, extend_method); end
  def new_alias_name(name, prefix = nil, postfix = nil); end
end
class RubyLex
  def check_code_block(code, tokens = nil); end
  def check_corresponding_token_depth; end
  def check_newline_depth_difference; end
  def check_state(code, tokens = nil); end
  def check_string_literal(tokens); end
  def each_top_level_statement; end
  def find_prev_spaces(line_index); end
  def initialize; end
  def initialize_input; end
  def is_method_calling?(tokens, index); end
  def is_the_in_correspond_to_a_for(tokens, index); end
  def lex; end
  def process_continue(tokens = nil); end
  def process_literal_type(tokens = nil); end
  def process_nesting_level(tokens = nil); end
  def prompt; end
  def ripper_lex_without_warning(code); end
  def self.compile_with_errors_suppressed(code); end
  def set_auto_indent(context); end
  def set_input(io, p = nil, &block); end
  def set_prompt(p = nil, &block); end
  def take_corresponding_syntax_to_kw_do(tokens, index); end
end
class RubyLex::TerminateLineInput < StandardError
  def initialize; end
end
class IRB::Locale
  def String(mes); end
  def each_localized_path(dir, file); end
  def each_sublocale; end
  def encoding; end
  def find(file, paths = nil); end
  def format(*opts); end
  def gets(*rs); end
  def initialize(locale = nil); end
  def lang; end
  def load(file, priv = nil); end
  def modifier; end
  def print(*opts); end
  def printf(*opts); end
  def puts(*opts); end
  def readline(*rs); end
  def real_load(path, priv); end
  def require(file, priv = nil); end
  def search_file(lib_paths, dir, file); end
  def territory; end
  def toplevel_load(*arg0); end
end
module IRB::Color
  def self.clear; end
  def self.colorable?; end
  def self.colorize(text, seq); end
  def self.colorize_code(code, complete: nil, ignore_error: nil); end
  def self.dispatch_seq(token, expr, str, in_symbol:); end
  def self.inspect_colorable?(obj, seen: nil); end
  def self.scan(code, allow_last_error:); end
  def self.supported?; end
  def self.without_circular_ref(obj, seen:, &block); end
end
class IRB::Color::SymbolState
  def initialize; end
  def scan_token(token); end
end
class InvalidName___Class_0x00___Vec_2
  def cross(other); end
  def dot(other); end
  def initialize(x, y, z); end
  def normalize; end
  def sub(other); end
  def x; end
  def y; end
  def z; end
end
class InvalidName___Class_0x00___Canvas_3
  def draw; end
  def initialize(arg0); end
  def line(arg0, arg1); end
  def line0(p1, p2); end
end
class InvalidName___Class_0x00___RubyModel_4
  def init_ruby_model; end
  def initialize; end
  def render_frame(i); end
end
class IRB::Abort < Exception
end
class IRB::Irb
  def assignment_expression?(line); end
  def context; end
  def convert_invalid_byte_sequence(str); end
  def eval_input; end
  def handle_exception(exc); end
  def initialize(workspace = nil, input_method = nil); end
  def inspect; end
  def output_value(omit = nil); end
  def prompt(prompt, ltype, indent, line_no); end
  def run(conf = nil); end
  def scanner; end
  def scanner=(arg0); end
  def signal_handle; end
  def signal_status(status); end
  def suspend_context(context); end
  def suspend_input_method(input_method); end
  def suspend_name(path = nil, name = nil); end
  def suspend_workspace(workspace); end
end
class Binding
end
